
---
title: React Native Development with GitHub Codespaces
description: Learn how to set up and use GitHub Codespaces for building React Native applications, focusing on Android development.
---

import { Steps, Aside } from '@astrojs/starlight/components';

GitHub Codespaces provides a powerful, cloud-based development environment accessible directly from your browser. This makes it an excellent choice for React Native development, especially for Android builds, as it eliminates complex local setup, reduces resource usage on your machine, and ensures a consistent environment across devices.

## Prerequisites

Your GitHub Codespace comes pre-installed with essential tools needed for React Native development:

-   **Node.js:** Multiple versions are usually available (e.g., v18, v20). You can switch versions if needed using tools like `nvm`.
-   **Java Development Kit (JDK):** Required for Android development (e.g., OpenJDK 17 or 21).

## Setting Up the Android Environment

While Node.js and Java are pre-installed, you need to set up the Android SDK manually within the Codespace.

<Steps>
1.  **Install Android Command Line Tools**

    Create a directory, download, extract, and organize the tools:
    ```bash
    # Create directory and navigate into it
    mkdir -p ~/android-sdk && cd ~/android-sdk

    # Download the latest command line tools (check for updated URLs if needed)
    wget https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip

    # Unzip and structure the tools correctly
    unzip commandlinetools-linux-*.zip
    mkdir -p cmdline-tools/latest
    mv cmdline-tools/* cmdline-tools/latest/ 2>/dev/null || true # Handles potential existing files
    rm commandlinetools-linux-*.zip # Clean up downloaded zip
    ```

2.  **Configure Environment Variables**

    Set the `ANDROID_HOME` variable and add the SDK tools to your `PATH` so they can be found by the system and React Native CLI.
    ```bash
    # Add environment variables to your shell configuration file (e.g., .bashrc or .zshrc)
    echo 'export ANDROID_HOME=$HOME/android-sdk' >> ~/.bashrc
    echo 'export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin:$ANDROID_HOME/platform-tools' >> ~/.bashrc

    # Apply the changes to your current session
    source ~/.bashrc
    ```
    <Aside type="tip">
    You might need to restart your terminal session or reload the Codespace window for these environment variables to be fully recognized everywhere.
    </Aside>

3.  **Install SDK Components**

    Use the `sdkmanager` tool to accept licenses and install the required Android SDK platforms, build tools, and other necessary components.
    ```bash
    # Accept all SDK licenses
    yes | $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager --licenses

    # Install required components (adjust versions as needed for your project)
    $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager \
      "platform-tools" \
      "platforms;android-34" \
      "build-tools;34.0.0" \
      "ndk;26.1.10909125"
    ```
</Steps>

## Developing Your App

With the environment set up, you can now initialize or work on your React Native project.

### Initializing a New Project

If starting fresh, use the React Native CLI:
```bash
# Replace YourProjectName with your desired project name
npx @react-native-community/cli init YourProjectName
cd YourProjectName
```

### Building for Debug

<Steps>
1.  **Install Dependencies**
    Navigate to your project's root directory and run:
    ```bash
    npm install
    # or yarn install
    ```

2.  **Prepare and Build Android Debug APK**
    ```bash
    cd android
    chmod +x gradlew  # Ensure gradlew script is executable
    ./gradlew clean   # Optional: Clean previous builds
    ./gradlew assembleDebug # Build the debug APK
    ```
    The debug APK will be located at `android/app/build/outputs/apk/debug/app-debug.apk`. You can download this file via the Codespaces file explorer to install on a physical device or an emulator.
</Steps>

### Running and Debugging on a Device

<Steps>
1.  **Start the Metro Bundler**
    In your project's root directory, start the Metro bundler which serves your JavaScript code:
    ```bash
    npx react-native start
    ```

2.  **Forward the Metro Port (8081)**
    GitHub Codespaces should automatically detect port 8081 being used and prompt you to forward it. Ensure it's forwarded and set to be publicly accessible. Note the unique URL provided for the forwarded port (it will look something like `https://your-codespace-name-random-string-8081.app.github.dev`).

3.  **Connect Your Physical Android Device**
    *   Install the `app-debug.apk` on your device.
    *   Ensure your device is connected to the internet.
    *   Open the app.
    *   Open the **Developer Menu** (usually by shaking the device or running `adb shell input keyevent 82` if connected via ADB).
    *   Go to **Settings** > **Debug server host & port for device**.
    *   Enter the **forwarded URL address** from Step 2, **removing** the `https://` prefix and including the port number (e.g., `your-codespace-name-random-string-8081.app.github.dev`).
    *   Go back and select **Reload** from the Developer Menu. The app should now load the bundle from your Codespace Metro server.
</Steps>

## Building for Release

To create a release build suitable for distribution, you need to sign your Android app.

<Steps>
1.  **Generate a Signing Key**

    Use `keytool` to generate a private signing key. Store this keystore file securely and back it up!
    ```bash
    # Navigate to the android/app directory first
    cd android/app

    # Generate the keystore
    keytool -genkeypair -v -keystore release.keystore -alias your-key-alias -keyalg RSA -keysize 2048 -validity 10000
    ```
    You will be prompted to create passwords for the keystore and the key. Remember these passwords.

    <Aside title="Securely Store Credentials" type="caution">
    Never commit your `release.keystore` file or passwords directly into version control. Create a `keystore.properties` file in the `android/app` directory (add it to `.gitignore`):
    ```properties
    # android/app/keystore.properties
    storeFile=release.keystore
    storePassword=YOUR_KEYSTORE_PASSWORD
    keyAlias=your-key-alias
    keyPassword=YOUR_KEY_PASSWORD
    ```
    Replace the placeholder passwords and alias with your actual credentials.
    </Aside>

2.  **Configure Gradle for Signing**

    Edit your `android/app/build.gradle` file to read the credentials from `keystore.properties` and set up the release signing configuration.

    ```groovy{4-8,21-29,38}
    // android/app/build.gradle
    ...
    // Add these lines near the top, outside the android { ... } block
    def keystorePropertiesFile = rootProject.file("app/keystore.properties")
    def keystoreProperties = new Properties()
    if (keystorePropertiesFile.exists()) {
        keystoreProperties.load(new FileInputStream(keystorePropertiesFile))
    }

    android {
        ...
        defaultConfig { ... }

        signingConfigs {
            debug {
                storeFile file('debug.keystore')
                storePassword 'android'
                keyAlias 'androiddebugkey'
                keyPassword 'android'
            }
            release {
                if (keystorePropertiesFile.exists()) {
                    storeFile file(keystoreProperties['storeFile'])
                    storePassword keystoreProperties['storePassword']
                    keyAlias keystoreProperties['keyAlias']
                    keyPassword keystoreProperties['keyPassword']
                } else {
                    // Optional: Fallback or error if properties are missing
                    println("Warning: Release keystore properties not found.")
                }
            }
        }

        buildTypes {
            debug {
                signingConfig signingConfigs.debug
                ...
            }
            release {
                // Apply the release signing configuration
                signingConfig signingConfigs.release
                // Enable code shrinking and obfuscation
                minifyEnabled true
                shrinkResources true
                proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
                ...
            }
        }
        ...
    }
    ```

3.  **Build the Release APK**

    Navigate back to the `android` directory and run the `assembleRelease` Gradle task:
    ```bash
    cd .. # Go back to android/ directory if you were in android/app/
    ./gradlew clean
    ./gradlew assembleRelease
    ```
    The signed release APK(s) will be generated in `android/app/build/outputs/apk/release/`.
</Steps>

## Optimizing APK Size (Optional: ABI Splitting)

To reduce the app's download size, you can generate separate APKs for different CPU architectures (Application Binary Interfaces - ABIs). Add the following `splits` block inside the `android { ... }` block in `android/app/build.gradle`:

```gradle
// android/app/build.gradle
android {
    // ... other configurations ...

    splits {
        abi {
            enable true // Enable ABI splitting
            reset() // Clear any existing filters
            // Specify architectures to build for (common choices shown)
            include "armeabi-v7a", "arm64-v8a" // Common for 32-bit and 64-bit ARM phones
            // include "x86", "x86_64" // Often needed for emulators or specific devices
            universalApk false // Set to true to also build one large APK containing all ABIs
        }
    }
}
```

<Aside type="note" title="Common Architectures">
*   **`arm64-v8a`**: Most modern 64-bit Android phones.
*   **`armeabi-v7a`**: Older 32-bit Android phones. Still relevant for broad compatibility.
*   **`x86_64` / `x86`**: Primarily for Android emulators running on computers or certain devices like Chromebooks.
</Aside>

After adding this configuration, running `./gradlew assembleRelease` again will produce multiple, smaller APK files in the output directory, each targeting a specific ABI. You would then upload these relevant APKs to the Google Play Store.
```

This version provides a more structured flow using Starlight's features, clarifies commands, adds important notes (like `.gitignore` and applying environment variables), and uses diff highlighting for the Gradle changes to make them clearer.