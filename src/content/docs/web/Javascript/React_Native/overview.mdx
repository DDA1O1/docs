---
 title: React Native
---

React Native was introduced by Facebook (now Meta) in 2015 as a solution to a growing challenge in mobile development. The framework was born out of Facebook's internal hackathon project, addressing the need to maintain separate codebases for iOS and Android apps while ensuring consistent user experiences.

### History and Purpose

The key innovation was enabling developers to write once and deploy across multiple platforms while maintaining native performance. Unlike previous cross-platform solutions, React Native renders using actual native UI components rather than webviews, resulting in apps that are indistinguishable from those built with native languages like Swift or Kotlin.

React Native rapidly gained popularity because it:
- Reduced development time and costs
- Enabled code sharing between platforms
- Offered hot reloading for faster iteration
- Provided access to native features when needed
- Allowed web developers to transition to mobile development

## JavaScript Interface(JSI)

JSI is a key part of React Native's New Architecture that replaces the old bridge system. It's a C++ layer that lets JavaScript talk directly to native code.

#### Old vs New Architecture

**Old Bridge System:**
- Used JSON to pass messages between JavaScript and native code
- All communication was asynchronous (had to wait for responses)
- Required extra processing to convert data

**JSI Benefits:**
- Direct communication with native code
- Can be synchronous (immediate) when needed
- Faster performance with less memory use
- Quicker app startup
- Enables modern React features like Suspense

### Turbo Modules

Turbo Modules are the improved version of Native Modules in React Native's New Architecture. They allow JavaScript code to access native platform features and APIs more efficiently.

#### How They Improve Native Modules

**Old Native Modules:**
- Loaded at app startup (even if never used)
- Communicated through the bridge with JSON serialization
- Async-only communication
- No type safety between JavaScript and native code

**Turbo Modules Benefits:**
- Lazy loading (only load when needed)
- Direct communication via JSI (no bridge)
- Support both sync and async calls
- Type-safe through CodeGen
- Better memory management
- Faster execution

Turbo Modules work hand-in-hand with JSI, giving JavaScript direct access to native functionality while maintaining the write-once-run-anywhere philosophy of React Native.

### Fabric

Fabric is React Native's new rendering system in the New Architecture. It completely reimagines how React components are rendered on mobile devices.

#### How Fabric Improves Rendering

**Old Rendering System:**
- Single-threaded UI updates
- Asynchronous layout calculations
- Required bridge serialization for all UI operations
- Limited concurrent work

**Fabric Benefits:**
- Multi-threaded rendering (smoother UI)
- Synchronous layout measurements when needed
- Direct access to native UI components via JSI
- Persistent UI trees for better state management

Fabric creates a persistent C++ rendering layer that exists on both JavaScript and native sides, allowing for more consistent UI behavior and better performance when handling complex interfaces.

## Expo

Expo is a platform built on top of React Native that provides a managed development environment with simplified workflows.

#### What is Expo

Expo is an open-source framework and platform that creates an abstraction layer on top of React Native. It provides:
- A set of pre-built components and APIs
- Development tools like Expo CLI and Expo Go
- Build services that handle native code compilation
- Over-the-air updates without app store approvals

#### Why React Native Recommends Expo

React Native documentation often suggests Expo for beginners and many projects because:
- **Quick Setup**: Start a new project with minimal configuration
- **Simplified Development**: Build without dealing with native code
- **Device Testing**: Preview apps instantly on physical devices via Expo Go
- **Managed Updates**: Push updates directly to users without app store reviews
- **Excellent Documentation**: Well-structured guides for beginners

#### Expo vs React+Vite

The Expo development experience is similar to React+Vite web development:
- Both prioritize developer experience with minimal configuration
- Both offer fast refresh for immediate feedback during development
- Both abstract away complex build processes
- Both provide optimized production builds
- Both focus on rapid iteration and testing

### React vs React Native Syntax

React and React Native share core principles and syntax structure, but have key differences in implementation.

#### Similarities

- **Component Architecture**: Both use component-based structure with JSX
- **Lifecycle Methods**: Same component lifecycle methods (componentDidMount, etc.)
- **Hooks**: Both support React hooks (useState, useEffect, useContext)
- **State Management**: Same approaches to managing state
- **Props System**: Identical prop passing between components

#### Differences

**Core Components**:
```jsx
// React Web
<div>
  <h1>Hello World</h1>
  <p>This is a paragraph</p>
</div>

// React Native
<View>
  <Text>Hello World</Text>
  <Text>This is a paragraph</Text>
</View>
```

**Styling**:
```jsx
// React Web
<div style={{ color: 'blue', marginTop: '20px' }}>
  Styled div
</div>

// React Native
<View style={{ color: 'blue', marginTop: 20 }}>
  <Text>Styled view</Text>
</View>
```

React Native also commonly uses StyleSheet:
```jsx
// React Native with StyleSheet
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
  }
});

<View style={styles.container}>
  <Text>Styled with StyleSheet</Text>
</View>
```

**Event Handling**:
```jsx
// React Web
<button onClick={handleClick}>Click me</button>

// React Native
<TouchableOpacity onPress={handlePress}>
  <Text>Press me</Text>
</TouchableOpacity>
```

**Layout System**:
React Native uses Flexbox as its primary layout system by default, while React web uses the traditional CSS layout system (including Flexbox, Grid, etc.).

**Navigation**:
React web typically uses libraries like React Router, while React Native employs specialized navigation libraries such as React Navigation.

### TailwindCSS in React Native

Unlike web development where TailwindCSS is directly supported, React Native requires special libraries to use Tailwind's utility-first styling approach.

#### NativeWind

NativeWind is the primary solution for bringing TailwindCSS to React Native applications. It allows developers to use familiar Tailwind classes across all platforms.

**How NativeWind Works:**
- Compiles Tailwind classes into platform-specific styles (StyleSheet.create for native, CSS StyleSheet for web)
- Processes styles during build time with minimal runtime for reactive styles
- Supports most Tailwind features including media queries, dark mode, and CSS variables

**Example Usage:**
```jsx
// React Native with NativeWind
import { View, Text } from 'react-native';
import { styled } from 'nativewind';

// Create styled components
const StyledView = styled(View);
const StyledText = styled(Text);

export default function App() {
  return (
    <StyledView className="flex-1 items-center justify-center bg-slate-100">
      <StyledText className="text-lg font-medium text-slate-900">
        Hello TailwindCSS in React Native!
      </StyledText>
    </StyledView>
  );
}
```
#### Setting up Expo with NativeWind

```bash
npx create-expo-stack@latest --nativewind
```
















