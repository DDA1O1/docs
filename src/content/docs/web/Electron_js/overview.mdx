---
title: 'Electron Vite Project: Setup and Build Process'
description: 'A step-by-step guide explaining how to create an Electron project using the Vite template and how the build process works, including installer behavior.'
---

import { Steps } from '@astrojs/starlight/components';

This guide walks through the process of setting up a new Electron project using the official Vite template and explains the subsequent build (`make`) command and its output, particularly focusing on the default Windows installer behavior.

<Steps>

1.  **Creating the Project with Vite Template**

    You initiated the project using `create-electron-app` with the Vite template:

    ```bash
    npx create-electron-app@latest my-app --template=vite
    ```

    *   **`npx create-electron-app@latest`**: Executes the latest version of the official Electron scaffolding tool.
    *   **`my-app`**: The name (and directory) for your new project.
    *   **`--template=vite`**: This crucial flag instructs the tool to set up:
        *   **Vite Integration**: Configures Vite for fast development (HMR) and optimized production builds.
        *   **Specific File Structure**: Creates `src/main.js`, `src/preload.js`, `src/renderer.js`, `index.html`, etc.
        *   **Vite Configuration Files**: Generates `vite.main.config.mjs`, `vite.preload.config.mjs`, `vite.renderer.config.mjs`.
        *   **Electron Forge Configuration**: Sets up `forge.config.js` including the `@electron-forge/plugin-vite` to bridge Electron Forge and Vite.
        *   **`package.json`**: Defines dependencies (Electron, Vite, Forge plugins) and scripts (`start`, `package`, `make`).

2.  **Building the Application**

    You then ran the build command:

    ```bash
    npm run make
    ```

    *   This executes the `make` script defined in your `package.json`, which points to `electron-forge make`.
    *   **Electron Forge (`electron-forge make`)** orchestrates the build process:
        1.  **Reads `forge.config.js`**: Determines how to build and package.
        2.  **Uses `@electron-forge/plugin-vite`**: Instructs Vite to build and bundle your `main`, `preload`, and `renderer` code based on the `vite.*.config.mjs` files. Output typically goes to `.vite/build/`.
        3.  **Creates Distributables (`makers`)**: Generates platform-specific packages based on the `makers` array in `forge.config.js`:
            *   `@electron-forge/maker-squirrel`: Creates a Windows installer (`Setup.exe`) using Squirrel.Windows.
            *   `@electron-forge/maker-zip`: Creates a `.zip` archive (configured for macOS).
            *   `@electron-forge/maker-deb`: Creates a `.deb` package (for Debian/Ubuntu Linux).
            *   `@electron-forge/maker-rpm`: Creates an `.rpm` package (for Fedora/RHEL Linux).
        4.  **Output**: Places the final packages in the `out` directory.

3.  **Understanding the Default Windows Installer Behavior (`.exe`)**

    When you ran the `.exe` generated by the default configuration, you observed:
    *   **No Installation Wizard**: It installed directly without typical steps (Welcome, License, Path Selection).
    *   **Quick Installation**: The process was very fast.
    *   **Immediate Launch**: The application opened right after installation.

    This behavior is characteristic of **Squirrel.Windows**, the technology used by `@electron-forge/maker-squirrel`:
    *   **Design Philosophy**: Prioritizes simplicity, speed, and seamless background updates over complex installation options.
    *   **No Wizard by Default**: Intentionally avoids a multi-step wizard.
    *   **User-Specific Install**: Typically installs to the user's `%LocalAppData%` folder, often not requiring admin rights.

4.  **Optional: Switching to a Traditional Windows Installer (NSIS)**

    If you prefer the conventional Windows installer experience with a setup wizard (License agreement, installation path selection, etc.), you need to use a different maker, such as `@electron-forge/maker-nsis`.

    1.  **Install the NSIS maker**:
        ```bash
        npm install --save-dev @electron-forge/maker-nsis
        # or
        # yarn add --dev @electron-forge/maker-nsis
        ```
    2.  **Modify `forge.config.js`**: Update the `makers` array to use `@electron-forge/maker-nsis` instead of (or in addition to) `@electron-forge/maker-squirrel`.

        ```javascript {3-8}
        // forge.config.js
        module.exports = {
          // ... other config ...
          makers: [
            {
              name: '@electron-forge/maker-nsis',
              config: {
                // Add NSIS-specific options here if needed
              },
            },
            // Keep other makers like zip, deb, rpm as needed
            { name: '@electron-forge/maker-zip', platforms: ['darwin'] },
            { name: '@electron-forge/maker-deb', config: {} },
            { name: '@electron-forge/maker-rpm', config: {} },
          ],
          // ... plugins ...
        };
        ```
    3.  **Re-run the build**:
        ```bash
        npm run make
        ```
        This will now generate an NSIS-based `.exe` installer that provides the familiar wizard interface.

5.  **Automating Releases with GitHub Actions**

    Initially, publishing was done locally using `npm run publish`. However, this proved to be **very slow** due to the large size of the distributable files (`.exe`, `.zip`, `.deb`, etc.) being uploaded over your local internet connection. Electron apps bundle the Chromium runtime, leading to package sizes often exceeding 100MB per platform.

    To address this bottleneck and automate the release process, we implemented a **GitHub Actions workflow**.

    **Why GitHub Actions?**

    *   **Speed:** GitHub Actions run on servers with very fast internet connections, dramatically reducing the time spent uploading large artifact files.
    *   **Automation:** The entire process of building for multiple platforms and publishing to GitHub Releases is triggered automatically when you push a specific Git tag (e.g., `v1.2.3`).
    *   **Consistency:** Ensures the build and release process is the same every time, reducing errors caused by local environment differences.
    *   **Free for Public Repos:** GitHub Actions provides generous free tiers, especially for open-source projects.

    :::danger[package.json]
     - Do not forget to update the the version of you application in package.json before running the `Github Actions` to reflect the new configurations in your app without you will stuck to the previous versions even if you push the updates 
    :::
    
    ```yml
    # .github/workflows/release.yml

    name: Release Electron App

    on:
    # Triggers the workflow on pushes that create a tag matching the pattern v*.*.* (e.g., v1.0.0, v1.2.3)
    push:
        tags:
        - 'v*.*.*'

    jobs:
    # Job to build for Windows x64
    build-windows-x64:
        runs-on: windows-latest # Use a Windows runner for Squirrel/EXE build
        steps:
        - name: Checkout Repository
            uses: actions/checkout@v4
            with:
            fetch-depth: 0

        - name: Setup Node.js
            uses: actions/setup-node@v4
            with:
            node-version: '20' # Or your preferred Node version
            cache: 'npm'

        - name: Install Dependencies
            run: npm ci

        # Explicitly make for win32 x64 using the configured Squirrel maker
        - name: Build Windows x64 (Make)
            run: npm run make -- --platform=win32 --arch=x64

        # Upload the contents of the make output directory for x64
        - name: Upload Windows x64 Artifact
            uses: actions/upload-artifact@v4
            with:
            name: windows-x64-artifact # Unique artifact name for x64 build
            path: out/make/**/* # Upload all files within the make output dir

    # Job to build for Windows ARM64
    build-windows-arm64:
        runs-on: windows-latest # Still needs a Windows runner
        steps:
        - name: Checkout Repository
            uses: actions/checkout@v4
            with:
            fetch-depth: 0

        - name: Setup Node.js
            uses: actions/setup-node@v4
            with:
            node-version: '20' # Or your preferred Node version
            cache: 'npm'

        - name: Install Dependencies
            run: npm ci

        # Explicitly make for win32 arm64 using the configured Squirrel maker
        - name: Build Windows arm64 (Make)
            run: npm run make -- --platform=win32 --arch=arm64 # Target arm64

        # Upload the contents of the make output directory for ARM64
        - name: Upload Windows arm64 Artifact
            uses: actions/upload-artifact@v4
            with:
            name: windows-arm64-artifact # Unique artifact name for ARM64 build
            path: out/make/**/* # Upload all files within the make output dir

    # Job to build for Linux x64 and arm64
    build-linux:
        runs-on: ubuntu-latest # Use a Linux runner for Deb builds
        steps:
        - name: Checkout Repository
            uses: actions/checkout@v4
            with:
            fetch-depth: 0

        - name: Setup Node.js
            uses: actions/setup-node@v4
            with:
            node-version: '20' # Or your preferred Node version
            cache: 'npm'

        # Install dependencies needed for building arm64 deb on x64 runner
        - name: Install Linux Build Dependencies
            run: |
            sudo apt-get update
            sudo apt-get install -y --no-install-recommends dpkg fakeroot

        - name: Install Project Dependencies
            run: npm ci

        # Explicitly make for linux x64 using the configured Deb maker
        - name: Build Linux x64 (Make)
            run: npm run make -- --platform=linux --arch=x64

        # Explicitly make for linux arm64 using the configured Deb maker
        - name: Build Linux arm64 (Make)
            run: npm run make -- --platform=linux --arch=arm64

        # Upload the contents of the make output directory (contains both .deb files)
        - name: Upload Linux Artifacts
            uses: actions/upload-artifact@v4
            with:
            name: linux-artifacts
            path: out/make/**/*

    # Job to create the GitHub Release and upload all built artifacts
    release:
        runs-on: ubuntu-latest
        # Depends on all three build jobs completing successfully
        needs: [build-windows-x64, build-windows-arm64, build-linux]
        permissions:
        contents: write # Needed to create releases and upload assets

        steps:
        - name: Checkout Repository # Needed to get tag info
            uses: actions/checkout@v4

        # Create a directory to download all artifacts into
        - name: Create Staging Directory
            run: mkdir staging

        # Download the artifact from the Windows x64 build job
        - name: Download Windows x64 Artifact
            uses: actions/download-artifact@v4
            with:
            name: windows-x64-artifact
            path: staging/windows-x64 # Contains squirrel.windows/x64 inside

        # Download the artifact from the Windows ARM64 build job
        - name: Download Windows arm64 Artifact
            uses: actions/download-artifact@v4
            with:
            name: windows-arm64-artifact
            path: staging/windows-arm64 # Contains squirrel.windows/arm64 inside

        # Download the artifact from the Linux build job
        - name: Download Linux Artifacts
            uses: actions/download-artifact@v4
            with:
            name: linux-artifacts
            path: staging/linux # Contains deb/x64 and deb/arm64 inside

        # --- CORRECTED RENAMING STEPS with proper working directory ---
        - name: Rename Windows x64 Artifacts for Uniqueness
            # Target the actual directory containing the files
            working-directory: staging/windows-x64/squirrel.windows/x64
            run: |
            echo "--- Files before renaming in $(pwd) ---"
            ls -l
            for FILE in *; do
                if [[ -f "$FILE" ]]; then # Ensure it's a file
                FILENAME="${FILE%.*}"
                EXTENSION="${FILE##*.}"
                if [[ "$FILENAME" == "$EXTENSION" ]] || [[ "$FILENAME" == "" ]]; then
                    NEW_NAME="${FILE}-x64"
                else
                    NEW_NAME="${FILENAME}-x64.${EXTENSION}"
                fi
                echo "Renaming '$FILE' to '$NEW_NAME'"
                mv "$FILE" "$NEW_NAME"
                fi
            done
            echo "--- Files after renaming in $(pwd) ---"
            ls -l

        - name: Rename Windows arm64 Artifacts for Uniqueness
            # Target the actual directory containing the files
            working-directory: staging/windows-arm64/squirrel.windows/arm64
            run: |
            echo "--- Files before renaming in $(pwd) ---"
            ls -l
            for FILE in *; do
                if [[ -f "$FILE" ]]; then # Ensure it's a file
                FILENAME="${FILE%.*}"
                EXTENSION="${FILE##*.}"
                if [[ "$FILENAME" == "$EXTENSION" ]] || [[ "$FILENAME" == "" ]]; then
                    NEW_NAME="${FILE}-arm64"
                else
                    NEW_NAME="${FILENAME}-arm64.${EXTENSION}"
                fi
                echo "Renaming '$FILE' to '$NEW_NAME'"
                mv "$FILE" "$NEW_NAME"
                fi
            done
            echo "--- Files after renaming in $(pwd) ---"
            ls -l
        # --- END OF CORRECTED RENAMING STEPS ---

        # List final files in staging for verification
        - name: List final staging files Tree
            run: ls -R staging

        # Use a dedicated action to create the release and upload artifacts
        - name: Create GitHub Release and Upload Artifacts
            uses: softprops/action-gh-release@v2
            with:
            tag_name: ${{ github.ref_name }}
            name: Release ${{ github.ref_name }}
            # The recursive glob should still find the renamed files in their nested paths
            files: staging/**/*
            env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    ```      
    **How the Workflow Works (`.github/workflows/release.yml`)**

    The workflow consists of multiple jobs designed to build the application on different operating systems and then consolidate the results into a single GitHub Release:

    1.  **Trigger:** The entire workflow is triggered **only** when a Git tag matching the pattern `v*.*.*` is pushed to the repository.
    2.  **Build Jobs (`build-windows-x64`, `build-windows-arm64`, `build-linux`):**
        *   These jobs run **in parallel** on different virtual machines (`windows-latest` or `ubuntu-latest`).
        *   Each job checks out the code, sets up Node.js, installs dependencies (`npm ci`), and runs `npm run make` specifically targeting one platform and architecture (e.g., `--platform=win32 --arch=x64`).
        *   Crucially, each build job uploads its resulting distributables (from the `out/make` directory) as a named **artifact** (e.g., `windows-x64-artifact`). Artifacts are temporary storage for files within a workflow run.
    3.  **Release Job (`release`):**
        *   This job **waits** for all the build jobs to complete successfully (`needs: [...]`).
        *   It runs on an `ubuntu-latest` runner.
        *   It **downloads** all the artifacts created by the build jobs into a `staging` directory.
        *   **Artifact Renaming:** It includes steps to rename the Windows artifacts (like `Setup.exe`, `.nupkg`) within their specific subdirectories (`staging/windows-x64/squirrel.windows/x64`, etc.) to prevent naming collisions when uploading multiple versions of the same filename to the GitHub Release. This was a key debugging step we went through, ensuring the renaming script targeted the correct nested directories where the maker placed the files.
        *   **Create GitHub Release:** It uses the `softprops/action-gh-release` action to:
            *   Create a new GitHub Release associated with the triggering tag (`${{ github.ref_name }}`).
            *   Upload *all* files found within the `staging` directory (including the renamed ones in their subdirectories) as assets to that release.
        *   **Authentication:** It uses the automatically provided `GITHUB_TOKEN` secret (enabled via the `permissions: contents: write` setting) for authenticating with GitHub to create the release and upload assets. No manual Personal Access Token is needed in the workflow file itself.

    By using this GitHub Actions workflow, the time-consuming build and upload process is offloaded to GitHub's infrastructure, resulting in a much faster and fully automated release pipeline for your Electron application whenever you push a new version tag.

</Steps>
