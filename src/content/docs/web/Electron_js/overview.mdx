---
title: 'Electron Vite Project: Setup and Build Process'
description: 'A step-by-step guide explaining how to create an Electron project using the Vite template and how the build process works, including installer behavior.'
---

import { Steps } from '@astrojs/starlight/components';

This guide walks through the process of setting up a new Electron project using the official Vite template and explains the subsequent build (`make`) command and its output, particularly focusing on the default Windows installer behavior.

<Steps>

1.  **Creating the Project with Vite Template**

    You initiated the project using `create-electron-app` with the Vite template:

    ```bash
    npx create-electron-app@latest my-app --template=vite
    ```

    *   **`npx create-electron-app@latest`**: Executes the latest version of the official Electron scaffolding tool.
    *   **`my-app`**: The name (and directory) for your new project.
    *   **`--template=vite`**: This crucial flag instructs the tool to set up:
        *   **Vite Integration**: Configures Vite for fast development (HMR) and optimized production builds.
        *   **Specific File Structure**: Creates `src/main.js`, `src/preload.js`, `src/renderer.js`, `index.html`, etc.
        *   **Vite Configuration Files**: Generates `vite.main.config.mjs`, `vite.preload.config.mjs`, `vite.renderer.config.mjs`.
        *   **Electron Forge Configuration**: Sets up `forge.config.js` including the `@electron-forge/plugin-vite` to bridge Electron Forge and Vite.
        *   **`package.json`**: Defines dependencies (Electron, Vite, Forge plugins) and scripts (`start`, `package`, `make`).

2.  **Building the Application**

    You then ran the build command:

    ```bash
    npm run make
    ```

    *   This executes the `make` script defined in your `package.json`, which points to `electron-forge make`.
    *   **Electron Forge (`electron-forge make`)** orchestrates the build process:
        1.  **Reads `forge.config.js`**: Determines how to build and package.
        2.  **Uses `@electron-forge/plugin-vite`**: Instructs Vite to build and bundle your `main`, `preload`, and `renderer` code based on the `vite.*.config.mjs` files. Output typically goes to `.vite/build/`.
        3.  **Creates Distributables (`makers`)**: Generates platform-specific packages based on the `makers` array in `forge.config.js`:
            *   `@electron-forge/maker-squirrel`: Creates a Windows installer (`Setup.exe`) using Squirrel.Windows.
            *   `@electron-forge/maker-zip`: Creates a `.zip` archive (configured for macOS).
            *   `@electron-forge/maker-deb`: Creates a `.deb` package (for Debian/Ubuntu Linux).
            *   `@electron-forge/maker-rpm`: Creates an `.rpm` package (for Fedora/RHEL Linux).
        4.  **Output**: Places the final packages in the `out` directory.

3.  **Understanding the Default Windows Installer Behavior (`.exe`)**

    When you ran the `.exe` generated by the default configuration, you observed:
    *   **No Installation Wizard**: It installed directly without typical steps (Welcome, License, Path Selection).
    *   **Quick Installation**: The process was very fast.
    *   **Immediate Launch**: The application opened right after installation.

    This behavior is characteristic of **Squirrel.Windows**, the technology used by `@electron-forge/maker-squirrel`:
    *   **Design Philosophy**: Prioritizes simplicity, speed, and seamless background updates over complex installation options.
    *   **No Wizard by Default**: Intentionally avoids a multi-step wizard.
    *   **User-Specific Install**: Typically installs to the user's `%LocalAppData%` folder, often not requiring admin rights.

4.  **Optional: Switching to a Traditional Windows Installer (NSIS)**

    If you prefer the conventional Windows installer experience with a setup wizard (License agreement, installation path selection, etc.), you need to use a different maker, such as `@electron-forge/maker-nsis`.

    1.  **Install the NSIS maker**:
        ```bash
        npm install --save-dev @electron-forge/maker-nsis
        # or
        # yarn add --dev @electron-forge/maker-nsis
        ```
    2.  **Modify `forge.config.js`**: Update the `makers` array to use `@electron-forge/maker-nsis` instead of (or in addition to) `@electron-forge/maker-squirrel`.

        ```javascript {3-8}
        // forge.config.js
        module.exports = {
          // ... other config ...
          makers: [
            {
              name: '@electron-forge/maker-nsis',
              config: {
                // Add NSIS-specific options here if needed
              },
            },
            // Keep other makers like zip, deb, rpm as needed
            { name: '@electron-forge/maker-zip', platforms: ['darwin'] },
            { name: '@electron-forge/maker-deb', config: {} },
            { name: '@electron-forge/maker-rpm', config: {} },
          ],
          // ... plugins ...
        };
        ```
    3.  **Re-run the build**:
        ```bash
        npm run make
        ```
        This will now generate an NSIS-based `.exe` installer that provides the familiar wizard interface.

5.  **Automating Releases with GitHub Actions**

    Initially, publishing was done locally using `npm run publish`. However, this proved to be **very slow** due to the large size of the distributable files (`.exe`, `.zip`, `.deb`, etc.) being uploaded over your local internet connection. Electron apps bundle the Chromium runtime, leading to package sizes often exceeding 100MB per platform.

    To address this bottleneck and automate the release process, we implemented a **GitHub Actions workflow**.

    **Why GitHub Actions?**

    *   **Speed:** GitHub Actions run on servers with very fast internet connections, dramatically reducing the time spent uploading large artifact files.
    *   **Automation:** The entire process of building for multiple platforms and publishing to GitHub Releases is triggered automatically when you push a specific Git tag (e.g., `v1.2.3`).
    *   **Consistency:** Ensures the build and release process is the same every time, reducing errors caused by local environment differences.
    *   **Free for Public Repos:** GitHub Actions provides generous free tiers, especially for open-source projects.

    **How the Workflow Works (`.github/workflows/release.yml`)**

    The workflow consists of multiple jobs designed to build the application on different operating systems and then consolidate the results into a single GitHub Release:

    1.  **Trigger:** The entire workflow is triggered **only** when a Git tag matching the pattern `v*.*.*` is pushed to the repository.
    2.  **Build Jobs (`build-windows-x64`, `build-windows-arm64`, `build-linux`):**
        *   These jobs run **in parallel** on different virtual machines (`windows-latest` or `ubuntu-latest`).
        *   Each job checks out the code, sets up Node.js, installs dependencies (`npm ci`), and runs `npm run make` specifically targeting one platform and architecture (e.g., `--platform=win32 --arch=x64`).
        *   Crucially, each build job uploads its resulting distributables (from the `out/make` directory) as a named **artifact** (e.g., `windows-x64-artifact`). Artifacts are temporary storage for files within a workflow run.
    3.  **Release Job (`release`):**
        *   This job **waits** for all the build jobs to complete successfully (`needs: [...]`).
        *   It runs on an `ubuntu-latest` runner.
        *   It **downloads** all the artifacts created by the build jobs into a `staging` directory.
        *   **Artifact Renaming:** It includes steps to rename the Windows artifacts (like `Setup.exe`, `.nupkg`) within their specific subdirectories (`staging/windows-x64/squirrel.windows/x64`, etc.) to prevent naming collisions when uploading multiple versions of the same filename to the GitHub Release. This was a key debugging step we went through, ensuring the renaming script targeted the correct nested directories where the maker placed the files.
        *   **Create GitHub Release:** It uses the `softprops/action-gh-release` action to:
            *   Create a new GitHub Release associated with the triggering tag (`${{ github.ref_name }}`).
            *   Upload *all* files found within the `staging` directory (including the renamed ones in their subdirectories) as assets to that release.
        *   **Authentication:** It uses the automatically provided `GITHUB_TOKEN` secret (enabled via the `permissions: contents: write` setting) for authenticating with GitHub to create the release and upload assets. No manual Personal Access Token is needed in the workflow file itself.

    By using this GitHub Actions workflow, the time-consuming build and upload process is offloaded to GitHub's infrastructure, resulting in a much faster and fully automated release pipeline for your Electron application whenever you push a new version tag.

</Steps>
